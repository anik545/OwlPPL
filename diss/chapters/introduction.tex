% !TeX root = ../diss.tex
\chapter{Introduction}
% \section{Motivation}

Creating statistical models and performing inference on these models is an important part of data science. A probabilistic programming languages (PPL) is a language used to create models, and allow inference to be performed on these models automatically. This allows the problem of efficient inference to be abstracted away from the specification of the model, and means inference code does not have to be hand-written for every model, making the task of designing models easier. Probabilistic models can then be written by domain experts, without having to worry about the task of inference. The inference `engine' can also implement many different inference algorithms, which will each be more or less well-suited to different types of models. The core idea is that we have a prior belief over some parameters, ($p(x)$, the generative model), and a set of conditions ($p(y|x)$) which specify the likelihood of observed data given those parameters. What we are interested in is the posterior, the (inferred) distribution over the parameters given the data we observe ($p(y|x)$). In general, this kind of Bayesian inference is intractable, so we must use methods which approximate the posterior.
% Performing inference on statistical models is key to data science. The general idea of all such modelling is to start with a prior belief over some parameters, (p(x), the generative model), and a set of conditions (p(y|x)) which specify the likelihood of observed data given those parameters. The data scientist then seeks to find the posterior, the (inferred) distribution over the parameters given the data we observe (p(y|x)).  As this kind of Bayesian inference is intractable in general, we must use methods which approximate the posterior. 

% A probabilistic programming language (PPL) is a language in which the programmer builds complex models through composition of simpler models and then approximates the posteriors by automatically performing inference on those complex models. The problem of performing efficient inference is thus separated from the specification of the model, allowing inference code to be written and optimised once, independent of any particular model. This greatly simplifies the task of designing models, and allows them to be produced by domain experts without them needing to worry about inference. It is also possible to vary the inference engine used in a PPL, allowing selection of an engine appropriate to the particular models in use. 

PPLs usually allow us to create these models as programs. However, since generative models are built up by sampling from probability distributions, PPLs need some way of modelling this non-determinism. Being able to condition programs on data is the other key part of PPLs, since we are interested in the posterior, which is conditional on the data. Without conditioning, we can run a program `forwards', which essentially means generating samples using the model we write. However, when we include a condition statement, we can infer the distribution of the input parameters based on the data we observe.

PPLs can either be standalone languages or be embedded into another language. Embedding a PPL into a pre-existing language allows us to utilise the full power of the `host' language, and gives us access to operations in the host language without having to implement them separately. This makes it easier to combine models with each other as well as integrate them more easily into other programs written in the host language. Specifically, embedding a DSL into OCaml allows us to represent a wide range of models using OCaml's inbuilt syntax, and leverage OCaml features such as an expressive type system or efficient native code generation.

\section{Related work}
There are many examples of PPLs, even as domain specific languages (DSLs) in OCaml. Some PPLs choose to limit the models that can be expressed in them in order to make inference more efficient - for example HANSEI in OCaml can only represent discrete distributions \cite{kiselyov2009embedded}. Others, such as STAN or infer.NET (F\#) can only operate on finite graphical models, and do not allow unbounded recursion when defining models. Some, such as Church or WebPPL, can express more general models, and are therefore known as `universal' \cite{borgstrom2016lambda} but often make the trade-off of less predictable or slower inference.

% mention what has been done - core and some extensions
% (here or abstract)


% TODO: mention "challenges", show non-trivial
