% !TeX root = ../diss.tex
\section{Motivation}

Creating statistical models and performing inference on these models is an important part of data science. A probabilistic programming languages (PPL) is a language used to create models, and allow inference to be performed on these models automatically. This allows the problem of efficient inference to be abstracted away from the specification of the model, and means inference code does not have to be hand-written for every model, making the task of designing models easier. Probabilistic models can then be written by domain experts, without having to worry about the task of inference. The inference `engine' can also implement many different inference algorithms, which will each be more or less well-suited to different types of models. The core idea is that we have a prior belief over some parameters, ($p(x)$, the generative model), and a set of conditions ($p(y|x)$) which specify the likelihood of observed data given those parameters. What we are interested in is the posterior, the (inferred) distribution over the parameters given the data we observe ($p(y|x)$). In general, this kind of Bayesian inference is intractable, so we must use methods which approximate the posterior.

PPLs usually allow us to create these models as programs. However, since generative models are built up by sampling from probability distributions, PPLs need some way of modelling this non-determinism. Being able to condition programs on data is the other key part of PPLs, since we are interested in the posterior, which is conditional on the data. Without conditioning, we can run a program `forwards', which essentially means generating samples using the model we write. However, when we include a condition statement, we can infer the distribution of the input parameters based on the data we observe.

PPLs can either be standalone languages or be embedded into another language. Embedding a PPL into a pre-existing language allows us to utilise the full power of the `host' language, and gives us access to operations in the host language without having to implement them separately. This makes it easier to combine models with each other as well as integrate them more easily into other programs written in the host language. Specifically, embedding a DSL into OCaml allows us to represent a wide range of models using OCaml's inbuilt syntax, and leverage OCaml features such as an expressive type system or efficient native code generation.

\section{Related works}
There are many examples of PPLs, even as domain specific languages (DSLs) in OCaml. Some PPLs choose to limit the models that can be expressed in them in order to make inference more efficient - for example HANSEI in OCaml can only represent discrete distributions \cite{kiselyov2009embedded}. Others, such as STAN or infer.NET (F\#) can only operate on finite graphical models, and do not allow unbounded recursion when defining models. Some, such as Church or WebPPL, can express more general models, and are therefore known as `universal' \cite{@article{borgstrom2016lambda,} but often make the trade-off of less predictable or slower inference.

% mention what has been done - core and some extensions
% (here or abstract)


% TODO: mention "challenges", show non-trivial
