% !TeX root = ../diss.tex

In this chapter, I will discuss the research done before starting the project, and some of the design decisions made based on this. In particular, common patterns in OCaml (and functional programming in general), influenced the final DSL, as well as the design of other similar probabilistic programming systems.

\section{Starting Point}

There do exist PPLs for OCaml, such as IBAL \cite{kiselyov2009embedded}, as well as PPLs for other languages, such as WebPPL - JS\cite{mobus2018structure}, Church - LISP\cite{goodman2012church} or Infer.Net - F\#\cite{wang2011using} to name a few. My PPL can draw on some of the ideas introduced by these languages, particularly in implementing efficient inference engines. I will need to research the different approaches taken by these PPLs and decide what form of PPL to implement, especially in deciding the types of model I will want my PPL to be able to represent and the inference methods I implement.

I will be using an existing OCaml numerical computation library (Owl). This library does not contain methods for probabilistic programming in general, although it does contain modules which will help in the implementation of an inference engine such as efficient random number generation and lazy evaluation.

I have experience with the core SML language, which will aid in learning basic OCaml due to similarities in the languages, however I will still have to learn the modules system. 1B Foundations of Data Science also gives me a basic understanding of Bayesian inference. I do not have experience with domain specific languages in OCaml, although the 1B compilers course did implement a compiler and interpreter in OCaml.

\section{Requirements}

Before starting to write any code, I made sure to set out the features I aimed to implement for my DSL. The main goal is to produce a usable language, which is defined by the following criteria:

% TODO: which tense to use here?
\begin{itemize}
    \item \textbf{Language Features}: Since I will write an embedded DSL, a user of my PPL should be able to take advantage of all standard OCaml features in their models. I need to make sure that this is the case, and features such as recursive functions will work.
    \item \textbf{Available distributions}: I will aim to make sure my PPL has at minimum the bernoulli and normal distributions available as basic building blocks to build more complex probabilistic programs.
    \item \textbf{Correctness} of inference: I will use the PPL developed on sample problems mentioned before to ensure correct results are produced. This would be determined by comparing to results produced in other PPLs as well as comparisons to analytic solutions for simple problems. I will aim to include at least one inference algorithm.
    \item \textbf{Performance}: This is a quantitative measure, comparing programs written in my PPL to equivalent programs in other PPLs. I can use tools such as spacetime or landmarks to profile my OCaml code. Performing inference should be possible within a reasonable amount of time, even though the project does not have a significant focus on performance. I will also benchmark the performance with regards to scalability, i.e. ensure the performance is still reasonable as models are conditioned on more data.
\end{itemize}



\section{Professional Practice}

I adopted several best practices in order to ensure the project was successful. This includes performing regular testing, splitting code into separate modules designing signatures first, and ensuring my code follows a consistent style guide (Jane Street style\footnote{\url{https://opensource.janestreet.com/standards/}})

\subsection{Testing}

Testing systems which are linked to randomness can be quite tricky, as it is difficult to test behaviour that is expected to change from one execution to the next. One approach is to set a fixed random seed and make sure the same sequence of results are produced. The aim of a unit test, however, is to make sure that a desired property does not change from one version of the code to the next. Even with a fixed random seed, a change in code may cause new outputs even though the fundamental statistical property desired hasn't changed. Another approach is to perform some statistical test such as kolmogorov-smirnov \cite{}, to ensure distributions produced by my library are equal to what is expected. A problem with tests of this kind is that they are expected to fail sometimes, meaning unit tests will provide limited utility due to their inherent flakiness with random programs. As such, most of the unit tests I will write will be fairly simple and only catch very basic bugs. However, I will still carry out evaluation 

\subsection{Licenses}

The major libraries I use, Owl and Jane Street Core, are both licensed under the MIT license.
% what else do i write here - the pink book says to talk about licenses

\section{Tools and Technologies}
The main tools I used are listed here:
\begin{itemize}
    \item Ocaml 4.08 - The language I wrote the main PPL library in
    \item Dune - Build system for OCaml
    \item Opam - OCaml package manager
    \item Alcotest - Unit testing framework
    \item Spacetime - Memory profiler for OCaml
    \item Landmarks - Profiler for OCaml
    \item Owl - Scientific computing library in OCaml
    \item VSCode (with ocaml extensions) - IDE for OCaml development
\end{itemize}

Using OCaml 4.08 allows me to use new features of OCaml, in particular the ability to define custom let operators as syntax sugar for monads. The dune build system also allows me to more easily manage building and testing my code, as well as automatically creating documentation from comments and function signatures in my code. The profilers I used allowed me to work out the causes of performance issues and remedy them. 


% This feels like it should be in implementation.
\section{Language Design}
I chose to implement my language as a domain specific language (DSL) shallowly embedded into the main OCaml language. This allows models built in the ppl to be easily composed with other standard OCaml programs.

Using a shallow embedding means we can use all of the features of OCaml as normal, including branching (if/then/else), loops, references, functions, and importantly, recursion. This can allow us to define models that do not terminate and are therefore invalid. However, we can write functions which are \textit{stochastic recursive}, that is, functions which have a probability of termination that tends to 1 as the number of successive calls tends to infinity.

I use a set of primitive distributions which can be combined (using arbitrarily complex deterministic OCaml code) to produce new more complex distribution. For example, one can take the sum of two discrete uniform distributions to simulate the addition of two dice rolls. 

PPLs in general are similar to normal programming languages, but need to support two extra operations - \texttt{sample} and \texttt{condition} \cite{}. The sample function is for sampling from some distribution - either a primitive distribution or a user defined distribution.

\section{OCaml}
I have chosen to use the OCaml language to implement my PPL. There are many features of OCaml 

\section{Owl}

Owl is a scientific computing library written for OCaml \cite{}. Importantly for my PPL, it contains functions for working with multi-dimensional arrays, as well as a wide variety of statistical functions. In particular, it contains functionality relating to many common distributions, e.g. normal, beta, binomial, etc. Since my language will allow the user to combine these basic distributions into larger models, I will need to use these functions to allow sampling from and the ability to perform inference on these models. In particular, it is important to be able to find the probability density function (pdf) and cumulative density function (cdf) of these distributions as well as sample from them. Another important feature of owl is it's plotting functionality which enabled me to write functions which let me visualise output distributions, as well as visualising performance statistics, all directly from OCaml.

% Should these parts be here? Do I explain the methods here or in the implementation section?
\section{Probability Monad}
% how in-depth should my explanation of a monad be?

\subsection{Monads}

Monads are a design pattern commonly used in functional programming languages.

The key data structure I use to model probability distributions is a monad. This allows me to compose distributions easily, by using the output from one distribution in another using the bind operator. In OCaml, I can also use the new (let*) operators to make this more ergonomic, and make code look more natural (as opposed to using the >>= operator everywhere).

\section{Approaches to probabilistic programming}
Existing PPLs take several different forms and can 


\section{Bayesian Inference}
Inference is a key motivating feature of probabilistic language, and is a way to infer parameters from the data we observe.

\section{Inference Algorithms}

Inference algorithms are ways of computing a posterior distribution given a prior and a generative model. We cannot usually compute an exact distribution, 

\subsection{Exact Inference}

Exact Inference is the simplest method of calculating the posterior, but is usually computationally intractable. It involves calculating bayes formula exactly, of which calculating the normalising constant is usually the problem.

\subsection{Importance Sampling}
\subsection{Monte Carlo Markov Chains (MCMC)}

MCMC methods involve finding a Markov chain whose stationary distribution is equal to the posterior distribution of interest

\subsection{Sequential Monte Carlo (SMC)}

SMC methods 

